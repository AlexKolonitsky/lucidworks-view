(function () {
  'use strict';

  angular
    .module('lucidworksView.controllers.simulation', [
      'lucidworksView.services.simulation',
      'lucidworksView.services.config',
      'lucidworksView.services.auth'
    ])
    .controller('simulationController', function ($log, $scope, $rootScope, $http, $sce, $window,
                                                  $interval, $timeout, $q, SimulationService, ConfigService, AuthService) {

      $rootScope.lw = ConfigService.config.simulation;

      $scope.showUIOptions = false;

      $rootScope.lw.pipelineIds = $rootScope.lw.pipelineIdList.split(','); //Derive a pipeline array from comma-delimited list
      $rootScope.lw.pipename = $rootScope.lw.pipelineIds[0]; //Default pipeline witll be the 1st one in $rootScope.lw.pipelineIds
      $rootScope.lw.requestHandlers = $rootScope.lw.requestHandlerList.split(','); //Derive an array from comma-delimited list
      $rootScope.lw.requestHandler = $rootScope.lw.requestHandlers[0]; //This specifies the requestHandler the main doSearch() will use.

      $scope.fields = $rootScope.lw.fl2display.split(',');

      $rootScope.lw.demo_actions_enabled = false; //demo_actions_enabled allows user to edit field values and submit signals
      $rootScope.lw.sort_by = 'default'; //'default' means sort by relevance.  User can select a different sort in the UI
      $rootScope.lw.sort_order = 'asc'; //'asc' for ascending, 'desc' is for descending

      $rootScope.lw.geo_enabled = false;
      $rootScope.lw.address = '';
      $rootScope.lw.coordinates = '';
      $rootScope.lw.geoMessage = '';

      $rootScope.lw.typeahead_logs_collection = $rootScope.lw.collection + '_logs';
      $rootScope.lw.typeahead_signals_collection = $rootScope.lw.collection + '_signals_aggr';

      $rootScope.lw.mm_options = [
        {label: 'Default', value: 'default'},
        {label: 'At least 2 terms', value: '2'},
        {label: 'At least 3 terms', value: '3'},
        {label: 'At least 50% of terms', value: '50%25'},
        {label: 'All search terms', value: '100%25'}
      ];
      $rootScope.lw.mm = 'default';

      $scope.q = '';
      $scope.search_within_q = '';
      $scope.fq = [];

      $scope.showResponseHeader = false;
      $scope.showResponse = false;
      $scope.showDebug = false;
      $scope.showExplain = false;
      $scope.isFacetFilterOpen = true; //Set to true to open Facet accordian at startup
      $scope.shortList = false; //Set to false to display full facet result
      $scope.notification_enabled = false; //Notifition window is hidden initially
      $scope.notification_msg = '';

      $scope.actionStatus = {};
      $scope.explain = {};
      $scope.rebuildSuggesterStatus = '';

      $scope.boost = []; //This array stores boost values listed in responseHeader.  Boost values are generated by signal-enabled query pipeline
      $scope.top_ten_searches = []; //This array holds the results of querying <collection>_logs for top 10 searches
      $scope.top_ten_docs = []; //This array holds the results of querying <collection>logs for top 10 clicked docs

      $scope.clearSearchBox = function () {
        $log.debug('***Clear Search Box... This function is called when you hit the "Clear" button');

        $scope.q = '';
        $scope.search_within_q = '';
        $scope.fq = [];
        if ($rootScope.lw.address != 'Current Location') {
          $rootScope.lw.address = '';
          $rootScope.lw.coordinates = '';
          $rootScope.lw.geoMessage = '';
        }
        $scope.actionStatus = {};
        $scope.explain = {};
        $scope.rebuildSuggesterStatus = '';
        $scope.data = {};
        $scope.facet_fields = {};
        $scope.facet_fields_count = 0;
        $scope.spellcheck_results = [];
      };

      function excludedRules() {
        if (!$scope.data || !$scope.data.fusion) {
          return '';
        }

        return _.chain($scope.data.fusion.applicable_rules)
          .filter(_.matches({enabled: false}))
          .map(function (rule) {
            return '&rules.exclude=' + rule.id;
          })
          .join('');

      }

      $scope.doSearch = function (start) {
        $log.debug("***BEGINNING OF doSearch... the main search function");

        var within = ''; //Search within results
        if ($rootScope.lw.search_within_results_enabled && $scope.search_within_q) {
          within = '&fq={!edismax}"' + $scope.search_within_q + '"';
        }

        var tagsSelected = $('div#tagsFilterWrapper button.depressed');
        var incexlStr = tagsSelected.length ? '&tags=' : '';
        $.each(tagsSelected, function (idx, el) {
          $log.debug(idx + ") Depressed: " + el);
          incexlStr += el.dataset['facet_label'] + ',';
        });

        $scope.notification_enabled = false;
        $scope.notification_msg = '';
        $scope.actionStatus = {};
        $scope.facet_fields = {};
        $scope.facet_fields_count = 0;
        $scope.spellcheck_results = [];
        $scope.explain = {};

        $('div#tagsFilterFooterWrapper').html(incexlStr);

        SimulationService.search($rootScope.lw, $scope.q, $scope.fq, within, start, excludedRules(), incexlStr,
          function (data, http_code, headers, config) {
          //With success, add INFO message to console and pass http response to search page fields
          $log.debug('doSearch SUCCESS: code=' + http_code + ', data=');
          $log.debug(data);
          processData(data);
          processFacetFields(data);
          processBoost(data);
          if ($rootScope.lw.spellCheck && $scope.q) {
            $scope.doSpellcheck()
          }
        }, errorHandler);

        $log.debug("***END OF doSearch");
      };

      function processData(data) {
        // This function is executed when doSearch $http.get is SUCCESSFUL.
        $scope.showResponseHeader = false;
        $scope.showResponse = false;
        $scope.showDebug = false;

        $scope.data = data;

        $scope.start = data.response.start;
        $scope.numFound = data.response.numFound;
        $scope.pageSize = data.responseHeader.params.rows;
        $scope.currentPage = ($scope.start / $scope.pageSize) + 1;

        $scope.numPages = Math.ceil($scope.numFound / $scope.pageSize);
        if ($scope.numPages > 10) {
          $scope.showPages = new Array(10); //Show a max of 10 paging boxes
        } else {
          $scope.showPages = new Array($scope.numPages);
        }

        if (angular.isArray(data.responseHeader.params.fq)) {
          $scope.fq = data.responseHeader.params.fq;
        }
      }

      function processFacetFields(data) {
        if (data.facet_counts) {
          $scope.facet_fields = _.mapValues(data.facet_counts.facet_fields, function (facet_field, facetName) {
            return _.map(facet_field, function (facet) {
              var fq = facetName + ':"' + facet[0] + '"';

              return {
                label: facet[0] + ' (' + facet[1] + ')',
                name: facet[0],
                fq: fq,
                checked: $scope.fq.indexOf(fq) != -1
              };
            })
          });

          $scope.facet_fields_count = Object.keys($scope.facet_fields).length;
        } else {
          $scope.facet_fields = {};
          $scope.facet_fields_count = 0;
        }

        $log.debug('facet_fields=', $scope.facet_fields);
        $log.debug('facet_fields_count=' + $scope.facet_fields_count);
        $log.debug('***END OF processFacetFields');
      }

      //***END OF processFacetFields

      //***processBoost from Fusion http.get query
      function processBoost(data) {
        $log.debug("***BEGINNING OF processBoost");
        var boost;
        $scope.boost = [];
        if (data.responseHeader.params.boost) {
          $log.debug('processBoost: boost field');
          boost = data.responseHeader.params.boost;
          $log.debug('typeof(boost): ' + typeof(boost));
          var boost_array = [];
          if (typeof(boost) == "string") {
            boost_array.push(boost);
          } else {
            boost_array = boost;
          }
          for (var i = 0; i < boost_array.length; i++) {
            var item = boost_array[i];
            $log.debug(item);
            if (/^map\(query\(\{!field f='id'/.test(item)) {
              var m = item.match(/v='([^']*)'/);
              var p = item.split(", ");
              $scope.boost[m[1]] = p[4].match(/[0-9\.]+/)[0];
            }
          }
        } else if (data.responseHeader.params.bq) {
          $log.debug('processBoost: bq field');
          boost = data.responseHeader.params.bq;
          $log.debug('typeof(boost): ' + typeof(boost));
          var boost_array = [];
          if (typeof(boost) == "string") {
            boost_array.push(boost);
          } else {
            boost_array = boost;
          }
          $log.debug('boost_array:');
          $log.debug(boost_array);
          for (var i = 0; i < boost_array.length; i++) {
            var item = boost_array[i];
            $log.debug(item);
            if (/^id:/.test(item)) {
              var m = item.match(/^id:(.*)/);
              var p = m[1].split("^");
              $scope.boost[p[0]] = p[1];
            }
          }
        }
        // $log.debug($scope.boost);
        $log.debug("***END OF processBoost");
      }

      //***END OF processBoost


      /**
       * When user click on a Top Ten Search value or SpellCheck suggestion, redo search using new value
       */
      $scope.reDoSearch = function (val) {
        $scope.q = val;
        $scope.doSearch(0);
      };


      //***doPipelineChange.  When user changes his pipeline selection
      $scope.doPipelineChange = function () {
        $log.debug('***doPipelineChange');
        $rootScope.lw.sort_by = 'default';
        $scope.data = {};
        $scope.doSearch(0);
      };
      //***END OF doPipelineChange


      $scope.doRequestHandlerChange = function () {
        $log.debug('***doRequestHandlerChange When user changes his requestHandler selection');
        $scope.data = {};
        $scope.doSearch(0);
      };

      $scope.doMmChange = function () {
        $log.debug('***doMmChange');
        $log.debug('lw.mm=' + $rootScope.lw.mm);
        $scope.data = {};
        $scope.doSearch(0);
      };

      function errorHandler (data, http_code, headers, config) {
        $log.debug('ERROR! code=' + http_code + ', data=');
        $log.debug(data);
        var msg = 'url = <a href="' + config.url + '" target="_blank">' + config.url + '</a><br/>';
        msg += 'method = ' + config.method + '<br/>';
        if (angular.isDefined(data.error)) {
          msg += 'response code = ' + http_code + ' (' + data.error.msg + ')';
        } else if (angular.isDefined(data.msg)) {
          msg += 'response code = ' + http_code + ' (' + data.msg + ')';
        } else {
          msg += 'response code = ' + http_code + '<br/>' + data;
        }
        $scope.notification_enabled = true;
        $scope.notification_msg = $sce.trustAsHtml(msg);

        return false;
      }


      $scope.doSpellcheck = function () {
        $log.debug("***BEGINNING of doSpellcheck. This is executed when we get 0 docs from doSearch()");

        $scope.notification_enabled = false;
        $scope.notification_msg = '';

        SimulationService.spellCheck($scope.q,
          function (data, http_code, headers, config) {
          $log.debug('doSpellcheck SUCCESS: code=' + http_code + ', data=');
          $log.debug(data);

          if (angular.isDefined(data.spellcheck.collations)) {
            $log.debug('spellcheck.collations...');
            var results = [];
            for (var collation in data.spellcheck.collations) {
              if (angular.isObject(collation)) {
                $log.debug(collation);
                results.push({
                  label: collation.collationQuery + ' (' + collation.hits + ')',
                  value: collation.collationQuery
                });
              }
            }
          } else if (angular.isDefined(data.spellcheck.suggestions)) {
            $log.debug('spellcheck.suggestions...');
            var results = [];
            for (var j in data.spellcheck.suggestions) {
              if (angular.isArray(j)) {
                $log.debug(j);
                results.push({
                  label: j[1] + ' (' + j[3] + ')',
                  value: j[1]
                });
              }
            }
          }
          $log.debug(results);
          $scope.spellcheck_results = results;
        }, errorHandler);

        $log.debug("***END OF doSpellcheck");
      };
      //***END OF doSpellcheck

      //***This function will return true if value is NOT an object.  It is used to determine whether I enable user to edit field value.
      //***At this time, I only support field value edits for single-value fields.
      $scope.isValueNotAnObject = function (doc, field, value) {
        var value_type = angular.isObject(value);
        value_type = !value_type;
        //$log.debug('doc=' + doc + ', field=' + field + ', value=' + value +  ', value_type=' + value_type);
        return value_type;
      };
      //***END OF isValueNotAnObject


      //***This function is use to determine if a doc field value exist so we can decide whether to display field name or not
      $scope.isValueDefined = function (val) {
        return angular.isDefined(val);
      };
      //***END OF isValueDefined;

      $scope.returnValue = function (val) {
        if (angular.isArray(val)) {
          return val.join(', ');
        } else {
          return val;
        }
      };

      //***TypeAheadSearch.   This is executed every time you type a character in search box.
      $scope.typeAheadSearch = function (val) {

        $log.debug('***BEGINNING OF typeAheadSearch');

        //We will have a promises array to collect all suggestions from every "enabled" typeahead mechanisms below.
        var promises = [];

        $scope.notification_enabled = false;
        $scope.notification_msg = '';

        var fields = $rootScope.lw.typeahead_terms_fl.split(',');

        if ($rootScope.lw.typeahead_terms_enabled) promises.push(typeAheadViaTerms(val, fields, $rootScope.lw.collection));
        if ($rootScope.lw.typeahead_suggester1_enabled) promises.push(typeAheadViaSuggester(val, $rootScope.lw.typeahead_suggester1_dictionary, $rootScope.lw.collection));
        if ($rootScope.lw.typeahead_suggester2_enabled) promises.push(typeAheadViaSuggester(val, $rootScope.lw.typeahead_suggester2_dictionary, $rootScope.lw.collection));
        if ($rootScope.lw.typeahead_logs_collection_enabled) promises.push(typeAheadViaSystemCollection(val, ['q_s'], $rootScope.lw.typeahead_logs_collection));
        if ($rootScope.lw.typeahead_signals_collection_enabled) promises.push(typeAheadViaSystemCollection(val, ['query_s'], $rootScope.lw.typeahead_signals_collection));

        return $q.all(promises).then(function (data) {
          $log.debug('$q.all data=');
          $log.debug(data);
          var results = [];

          for (var i = 0; i < data.length; i++) {
            var bucket = data[i];
            for (var j = 0; j < bucket.length; j++) {
              results.push(bucket[j]);
            }
          }
          $log.debug('results=');
          $log.debug(results);
          $log.debug('***END OF typeAheadSearch');
          return results;
        });
      };
      //***END OF typeAheadSearch

      //***Get typeahead via terms requestHander
      function typeAheadViaTerms(val, fields, collection) {
        $log.debug('***BEGINNING OF typeAheadViaTerms');
        var terms_fl = '';
        for (var k = 0; k < fields.length; k++) {
          terms_fl += '&terms.fl=' + fields[k];
        }

        var url = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + collection
          + '/' + $rootScope.lw.typeahead_terms_requesthandler + '?wt=json&terms.sort=count&terms.limit=' + $rootScope.lw.typeahead_retrieve_num
          + terms_fl + '&terms.prefix=' + val;
        $log.debug('url=' + url);

        return $http.get(url, $rootScope.lw.authorizationHeader).error(errorHandler).then(function (response) {
          $log.debug('typeAheadViaTerms response=');
          $log.debug(response);

          var results = [];
          for (var j = 0; j < fields.length; j++) {
            var field = fields[j];
            $log.debug('terms for ' + field);
            var d = response.data.terms[field];
            $log.debug(d);
            for (var i = 0; i < d.length; i++) {
              if (i % 2 == 0) {
                var payload = {};
                payload.helper = 'from ' + field + ' field';
                payload.display_value = d[i];
                if ($rootScope.lw.field_fq_enabled) {
                  payload.value = field + ':"' + d[i] + '"';
                } else {
                  payload.value = d[i];
                }
                results.push(payload);
              }
            }
          }
          $log.debug('***END OF typeAheadViaTerms');
          return results;
        })
      }

      //***Get typeahead via suggester requestHander
      function typeAheadViaSuggester(val, dictionary, collection) {
        $log.debug('***BEGINNING OF typeAheadViaSuggester');
        var url = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + collection
          + '/' + $rootScope.lw.typeahead_suggester_requesthandler + '?wt=json&suggest.count=' + $rootScope.lw.typeahead_retrieve_num
          + '&suggest.dictionary=' + dictionary + '&suggest.q=' + val;
        $log.debug('url=' + url);

        return $http.get(url, $rootScope.lw.authorizationHeader).error(errorHandler).then(function (response) {
          $log.debug('typeAheadViaSuggester response=');
          $log.debug(response);

          var results = response.data.suggest[dictionary][val].suggestions.map(function (i) {
            var term = i.term.replace(/<b>/g, '').replace(/<\/b>/g, '');

            return {
              helper: 'from ' + dictionary,
              display_value: term,
              value: term
            };
          });

          $log.debug('***END OF typeAheadViaSuggester');
          return results;
        });
      }

      //***END OF typeAheadViaSuggester

      //***Get suggestion via logs and signals collections
      function typeAheadViaSystemCollection(val, fields, collection) {
        $log.debug('***BEGINNING OF typeAheadViaSystemCollection');
        var terms_fl = '';
        for (var k = 0; k < fields.length; k++) {
          terms_fl += '&terms.fl=' + fields[k];
        }
        var url = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + collection +
          '/' + $rootScope.lw.typeahead_terms_requesthandler + '?wt=json&terms.sort=count&terms.limit=' + $rootScope.lw.typeahead_retrieve_num + terms_fl + '&terms.prefix=' + val;
        $log.debug('url=' + url);

        return $http.get(url, $rootScope.lw.authorizationHeader).error(errorHandler).then(function (response) {
          var results = [];
          for (var j = 0; j < fields.length; j++) {
            var field = fields[j];
            $log.debug('terms for ' + field);
            var d = response.data.terms[field];
            $log.debug(d);
            //***solr json format for /terms requesthandler is array [] when distrib=false, but list {} when distrib=true!!!  Crazy!
            if (angular.isArray(d)) {
              for (var i = 0; i < d.length; i++) {
                if (i % 2 == 0) {
                  var payload = {};
                  payload.helper = 'from ' + collection;
                  payload.display_value = d[i];
                  payload.value = d[i];
                  results.push(payload);
                }
              }
            } else {
              var k = Object.keys(d);
              $log.debug(k);
              for (var i = 0; i < k.length; i++) {
                var payload = {};
                payload.helper = 'from ' + collection;
                payload.display_value = k[i];
                payload.value = k[i];
                results.push(payload);
              }
            }

          }
          $log.debug('***END OF typeAheadViaSystemCollection');
          return results;
        })
      }

      //***END OF typeAheadFromSystemCollection


      $scope.updateRules = function (evnt, rule) {
        // todo -- I have no idea what I'm doing in angular, need to refactor to be cool, going with jquery experience... SoC
        // try: http://geniuscarrier.com/ng-toggle-in-angularjs/
        $log.debug('Item:', rule);

        if (rule.simulation == undefined) {
          rule.simulation = rule.enabled;
        }

        rule.simulation = !rule.simulation;
        $scope.doSearch(0);
      };


      /**
       * helper to filter clicked facet button from ui
       * @param facet -- string value at the moment
       * @todo revisit param, will have problems with spaces and lots of other unforeseen issues
       */
      $scope.updateTagsFilter = function (facet) {
        // todo -- I have no idea what I'm doing in angular, need to refactor to be cool, going with jquery experience... SoC
        $log.debug('exclude tags by Facet: ' + facet);
        var btn$ = $('button.tagsButton.' + facet);
        // var btn$ = $('button#rule_btn_' + item.id);
        btn$.toggleClass('depressed');
        $scope.doSearch(0);
      };


      $scope.updateFq = function (checked, item) {
        if (!checked) {
          $scope.fq.push(item);
        } else {
          var i;
          for (i in $scope.fq) {
            if ($scope.fq[i] == item) {
              $scope.fq.splice(i, 1);
              break;
            }
          }
        }
        $log.debug('fq=');
        $log.debug($scope.fq);
        //redo search
        $scope.doSearch(0);
      };

      //***toggle_geo_enabled.  This is execute when user click on the globe next to main search box.  This toggles geospatial search
      $scope.toggle_geo_enabled = function () {
        if ($rootScope.lw.geo_enabled == true) {
          $rootScope.lw.geo_enabled = false;
          $rootScope.lw.sort_by = 'default';
          $scope.doSearch(0);
        } else {
          $rootScope.lw.geo_enabled = true;
          $rootScope.lw.sort_by = 'distance';
          if ($rootScope.lw.coordinates != '') {
            $scope.doSearch(0)
          }
        }
      };

      //***doGeocode using Google geocode API
      $scope.doGeocode = function () {
        if ($rootScope.lw.address == '') {
          $rootScope.lw.geoMessage = 'Please enter a valid address';
          $rootScope.lw.geo_enabled = false;
          $rootScope.lw.sort_by = 'default';
          return;
        }
        if ($rootScope.lw.address == 'Current Location') {
          $scope.getCurrentLocation();
          return;
        }

        $rootScope.lw.geoMessage = '';
        $rootScope.lw.coordinates = '';
        $scope.http_request = 'http://maps.googleapis.com/maps/api/geocode/json?address=' + $rootScope.lw.address;

        //Perform http.get
        $http.get($scope.http_request).success(function (data, http_code, headers, config) {
          //With success, add INFO message to console and pass http response to search page fields
          $log.debug('doGeocode SUCCESS: code=' + http_code + ', data=');
          $log.debug(data);
          $log.debug('header=');
          $log.debug(headers);
          $log.debug('config=');
          $log.debug(config);
          if (data.status == "OK") {
            $rootScope.lw.coordinates = data.results[0].geometry.location.lat + ',' + data.results[0].geometry.location.lng;
            $rootScope.lw.geo_enabled = true;
            $rootScope.lw.sort_by = 'distance';
            $scope.doSearch(0);
          } else {
            $rootScope.lw.geoMessage = 'Google Geocode error: ' + data.status + ' for ' + $rootScope.lw.address;
            $rootScope.lw.geo_enabled = false;
            $rootScope.lw.sort_by = 'default';
          }
        }).error(function (data, http_code, headers, config) {
          $log.debug('doGeocode ERROR! code=' + http_code + ', data=');
          $log.debug(data);
          $log.debug('header=');
          $log.debug(headers);
          $log.debug('config=');
          $log.debug(config);
          $rootScope.lw.geoMessage = 'Google Geocode is UNREACHABLE: httpCode=' + http_code;
          $rootScope.lw.geo_enabled = false;
          $rootScope.lw.sort_by = 'default';
        });
      };

      //***Get device/browser current location for geospatial search
      $scope.getCurrentLocation = function () {
        $rootScope.lw.geoMessage = '';
        $rootScope.lw.coordinates = '';
        $rootScope.lw.address = "Current Location";
        if (navigator.geolocation) {
          // timeout at 60000 milliseconds (60 seconds)
          var options = {timeout: 60000};
          navigator.geolocation.getCurrentPosition($scope.setLocation, $scope.errorHandler, options);
        } else {
          alert("Sorry, browser does not support geolocation!");
        }
        $rootScope.lw.sort_by = 'distance';
      };
      $scope.setLocation = function (position) {
        var latitude = position.coords.latitude;
        var longitude = position.coords.longitude;
        $log.debug("Latitude : " + latitude + " Longitude: " + longitude);
        $rootScope.lw.coordinates = latitude + ',' + longitude;

        $rootScope.lw.geo_enabled = true;
        $rootScope.lw.sort_by = 'distance';
        $scope.doSearch(0);
      };

      $scope.errorHandler = function (err) {
        if (err.code == 1) {
          alert("Error: Access is denied!");
        } else if (err.code == 2) {
          alert("Error: Position is unavailable!");
        }
      };

      //***END OF section for getting device/browser current location


      //***If head field value is blank, then set text to "_blank_"
      $scope.displayHeadField = function (text) {
        if (!angular.isDefined(text)) {
          text = "_empty_";
        } else if (angular.isArray(text)) {
          text = text.join(', ');
        } else if (text.trim() == "") {
          text = "_blank_";
        }
        return text;
      };

      //***returnMappedLabel.  Use labels for field name if labels are specified in $rootScope.lw.labels
      $scope.returnMappedLabel = function (val) {
        return $sce.trustAsHtml($rootScope.lw.labels[val] || val);
      };

      //***doTopTenDocsAction.  Similar to docHeadFieldAction but not signals submissions
      $scope.doTopTenDocsAction = function (docID, docHeadFieldValue, urlFieldName, urlFieldValue) {
        $log.debug('doTopTenDocsAction docID:' + docID + ', docHeadFieldValue:' + docHeadFieldValue + ', urlFieldName:' + urlFieldName + ', urlFieldValue:' + urlFieldValue);

        if (urlFieldName.indexOf("coord") > -1) {
          window.open('https://maps.google.com/maps?q=' + urlFieldValue, '_blank');
        } else if (urlFieldValue.toString().indexOf("http") == 0) {
          window.open(urlFieldValue, '_blank');
        } else if (urlFieldValue.toString().indexOf("www.") == 0) {
          window.open('http://' + urlFieldValue, '_blank');
        } else if (docHeadValue.toString().indexOf("http") == 0) {
          window.open(docHeadValue, '_blank');
        }
        return false;
      };


      /**
       * This function controls the behavior of head field click action.
       * When "Demo Actions" is enabled, clicking a doc head field will trigger submission of signals (clicks).
       * Otherwise, click a doc head field will trigger action based on $rootScope.lw.head_url_field
       * and head url field value.
       * */
      $scope.doHeadFieldAction = function (docID, docHeadFieldValue, urlFieldName, urlFieldValue) {
        $log.debug('doHeadAction docID:' + docID + ', docHeadFieldValue:' + docHeadFieldValue + ', urlFieldName:' + urlFieldName + ', urlFieldValue:' + urlFieldValue);

        if ($rootScope.lw.demo_actions_enabled) {
          if ($scope.q) {
            $scope.submitSignals(docID);
          } else {
            $scope.actionStatus[docID] = "You need to search for something 1st before you can submit clicks.";
          }
        } else {
          if (urlFieldName != '' && urlFieldName == $rootScope.lw.geofield) {
            window.open('https://maps.google.com/maps?q=' + urlFieldValue, '_blank');
          } else if (urlFieldValue.toString().indexOf("http") == 0) {
            window.open(urlFieldValue, '_blank');
          } else if (urlFieldValue.toString().indexOf("www.") == 0) {
            window.open('http://' + urlFieldValue, '_blank');
          } else if (docHeadValue.toString().indexOf("http") == 0) {
            window.open(docHeadValue, '_blank');
          }
        }
        return false;
      };

      $scope.getThumbnailUrl = function (thumbnail_field_value) {

        var thumbnail_field = $rootScope.lw.thumbnail_field;

        if (angular.isArray(thumbnail_field_value)) {
          thumbnail_field_value = thumbnail_field_value.join(',');
        }

        if (thumbnail_field == $rootScope.lw.geofield) {
          return 'https://maps.googleapis.com/maps/api/streetview?&key=AIzaSyCL2yMd2faskEVdfNsxTbY_q84U6wt4a5A&size=120x120&location=' + thumbnail_field_value;
        } else if (thumbnail_field == 'prod_id') {
          return 'http://rei.com/zoom/' + thumbnail_field_value;
        } else {
          return thumbnail_field_value;
        }
      };

      $scope.doRebuildSuggester = function () {
        $scope.rebuildSuggesterStatus = 'Suggester rebuild initiated.  Please wait.';

        var url = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + $rootScope.lw.collection
          + '/' + $rootScope.lw.typeahead_suggester_requesthandler + '?suggest.buildAll=true';
        $log.debug('url=' + url);
        $http.get(url, $rootScope.lw.authorizationHeader).success(function (data, http_code) {
            $log.debug('doRebuildSuggester SUCCESS: code=' + http_code + ', data=');
            $log.debug(data);
            $scope.rebuildSuggesterStatus = 'Rebuild successful';
          })
          .error(function (data, http_code) {
            $log.debug('doRebuildSuggester ERROR: code=' + http_code + ', data=');
            $log.debug(data);
            $scope.rebuildSuggesterStatus = 'Rebuild failed with code = ' + http_code;
          });
      };

      $scope.getTopTenSearches = function () {
        $log.debug('***BEGINNING OF getTopTenSearches');

        //Top 10 Searches is achieved by facet <collection>_logs by q_s
        var url = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + $rootScope.lw.collection
          + '_logs/select?&wt=json&q=*:*&df=q_s&rows=0&facet=true&facet.field=q_s&facet.limit=10&facet.missing=false&fq=-{!term f=q_s}*:*';
        $log.debug('url=' + url);

        $http.get(url, $rootScope.lw.authorizationHeader)
          .error(function (data, http_code) {
            $log.debug('getTopTenSearches ERROR: code=' + http_code + ', data=' + data);
          })
          .then(function (response) {
            $log.debug('getTopTenSearches SUCCESS: response=');
            $log.debug(response);

            if (response.data.facet_counts.facet_fields) {
              var facet_bucket = response.data.facet_counts.facet_fields['q_s'];
              if (facet_bucket.length > 0) {

                var new_facet_bucket = [];

                for (var i = 0; i < facet_bucket.length; i++) {
                  if (i % 2 == 0 && facet_bucket[i + 1] != 0) {
                    new_facet_bucket.push({
                      value: facet_bucket[i],
                      label: facet_bucket[i] + ' (' + facet_bucket[i + 1] + ')'
                    });
                  }
                }

                $scope.top_ten_searches = new_facet_bucket;
                $log.debug('extracted top_ten_searches=');
                $log.debug($scope.top_ten_searches);
              }
            }
          });
        $log.debug('***END OF getTopTenSearches');
      };

      $scope.getTopTenDocs = function () {
        $log.debug('***BEGINNING OF getTopTenDocs');

        var ids = [];
        var ids_encoded = [];
        var id_count = {};

        var url = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + $rootScope.lw.collection
          + '_signals_aggr/select?&wt=json&q=*:*&df=query_s&rows=0&facet=true&facet.field=doc_id_s&facet.limit=10&facet.missing=false';
        $log.debug('url=' + url);

        $http.get(url, $rootScope.lw.authorizationHeader)
          .error(function (data, http_code) {
            $log.debug('getTopTenDocs ERROR: code=' + http_code + ', data=' + data);
          })
          .then(function (response) {
            $log.debug('getTopTenDocs SUCCESS: response=');
            $log.debug(response);
            if (response.data.facet_counts.facet_fields) {
              var facet_bucket = response.data.facet_counts.facet_fields['doc_id_s'];
              if (facet_bucket.length > 0) {

                for (var i = 0; i < facet_bucket.length; i++) {
                  if (i % 2 == 0) {
                    var id = facet_bucket[i];
                    ids.push(id);
                    ids_encoded.push('"' + id.replace(/%/g, '%25').replace(/#/g, '%23') + '"');
                    id_count[id] = facet_bucket[i + 1];
                  }
                }

                $log.debug('id and id_count=');
                $log.debug(ids_encoded.join(' OR '));
                $log.debug(id_count);

                var url2 = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + $rootScope.lw.collection
                  + '/select?&wt=json&q=(' + ids_encoded.join(' OR ') + ')';
                $log.debug('url2=' + url2);

                $http.get(url2, $rootScope.lw.authorizationHeader)
                  .error(function (data, http_code) {
                    $log.debug('getTopTenDocs 2ND ERROR: code=' + http_code + ', data=' + data);
                  })
                  .then(function (response) {
                    $log.debug('getTopTenDocs 2ND SUCCESS: response=');
                    $log.debug(response);

                    var bucket = response.data.response.docs;
                    var head_field_values = {};
                    var head_url_values = {};
                    if (bucket.length > 0) {

                      var head_field_value;
                      var head_url_value;
                      for (var i = 0; i < bucket.length; i++) {
                        var id = bucket[i]['id'];
                        if (bucket[i][$rootScope.lw.head_field]) {
                          head_field_value = bucket[i][$rootScope.lw.head_field];
                        } else {
                          head_field_value = '_blank_';
                        }

                        if (bucket[i][$rootScope.lw.head_url_field]) {
                          head_url_value = bucket[i][$rootScope.lw.head_url_field];
                        } else {
                          head_url_value = '_blank_';
                        }

                        $log.debug('head_field_value=' + head_field_value + ' head_url_value=' + head_url_value);

                        head_field_values[id] = head_field_value;
                        head_url_values[id] = head_url_value;
                      }
                      $log.debug('head_field_values=');
                      $log.debug(head_field_values);
                      $log.debug('head_url_values=');
                      $log.debug(head_url_values);

                      var results = [];
                      for (var i = 0; i < ids.length; i++) {
                        var id = ids[i];
                        var j = {};
                        j['id'] = id;
                        j['label'] = head_field_values[id] + ' (' + id_count[id] + ')';
                        j[$rootScope.lw.head_field] = head_field_values[id];
                        j[$rootScope.lw.head_url_field] = head_url_values[id];

                        $log.debug('j=');
                        $log.debug(j);
                        results.push(j);
                      }
                      $scope.top_ten_docs = results;

                      $log.debug('extracted top_ten_docs=');
                      $log.debug($scope.top_ten_docs);
                    }
                  });

              }
            }
          });
        $log.debug('***END OF getTopTenDocs');
      };


      //***doFieldUpdate.  This is used to update a field value in your solr collection
      $scope.doFieldUpdate = function (docID, field, value, orig_value) {
        $log.debug('***doFieldUpdate');
        var payload = [];
        var aDoc = {};
        aDoc["id"] = docID;
        if (!angular.isDefined(orig_value)) {
          $log.debug('orig_value is UNDEFINED');
          orig_value = 'UNDEFINED';
        }
        aDoc['_ORIG_' + field] = {"add": orig_value};
        payload.push(aDoc);
        $log.debug('payload=');
        $log.debug(payload);

        //Do http.post to solr update requestHandler to store original field value 1st
        var http_request = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + $rootScope.lw.collection + '/update?commit=true';
        $http.post(http_request, payload, $rootScope.lw.authorizationHeader).success(function (data, http_code) {
            $log.debug('doFieldUpdate for _ORIG_ SUCCESS: code=' + http_code + ', data=');
            $log.debug(data);
          })
          .error(function (data, http_code) {
            $log.debug('doFieldUpdate for _ORIG_ ERROR: code=' + http_code + ', data=' + data);
          });

        payload = [];
        aDoc = {};
        aDoc["id"] = docID;
        aDoc[field] = {"set": value};
        payload.push(aDoc);
        $log.debug('SECOND TIME payload=');
        $log.debug(payload);

        //Do http.post to solr update requestHandler to set NEW field value 1st
        http_request = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + $rootScope.lw.collection + '/update?commit=true';
        $http.post(http_request, payload, $rootScope.lw.authorizationHeader).success(function (data, http_code) {
            $log.debug('doFieldUpdate for NEW field value - SUCCESS: code=' + http_code + ', data=');
            $log.debug(data);
            $scope.actionStatus[docID + field] = 'Save successful for "' + value + '"';
          })
          .error(function (data, http_code) {
            $log.debug('doFieldUpdate for NEW field value - ERROR: code=' + http_code + ', data=');
            $log.debug(data);
            if (data.error) {
              $scope.actionStatus[docID + field] = 'Save FAILED - ' + data.error.msg;
            } else {
              $scope.actionStatus[docID + field] = 'Save FAILED - CODE=' + http_code;
            }
          });

        $log.debug('***END OF doFieldUpdate');
      };


      //***This function submits signals to the <collection>_signals
      $scope.submitSignals = function (docID) {
        $log.debug('***BEGINNING OF submitSignals');
        var d = new Date();
        var ts = d.toISOString();
        var params = {};
        params["docId"] = docID;
        params["query"] = $scope.q;
        params["source_s"] = 'simulated';
        params["source_type_s"] = 'advUI';
        var signal_payload = {};
        signal_payload["type"] = $rootScope.lw.signalType;
        signal_payload["timestamp"] = ts;
        signal_payload["params"] = params;
        var indata = [];
        for (var i = 0; i < $rootScope.lw.signalNum; i++) {
          indata.push(signal_payload)
        }

        $log.debug(indata);

        var url = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/signals/' + $rootScope.lw.collection + '?commit=true'
          + '&pipeline=' + $rootScope.lw.signals_pipeline;
        $log.debug('url=' + url);

        //Perform http post for submitSignals
        $http.post(url, indata, $rootScope.lw.authorizationHeader).success(function (data, http_code) {
            $log.debug('submitSignals SUCCESS: code=' + http_code + ', data=');
            $log.debug(data);
            $scope.actionStatus[docID] = $rootScope.lw.signalNum + ' ' + $rootScope.lw.signalType + ' successfully submitted. docID=' + docID;
          })
          .error(function (data, http_code) {
            $log.debug('submitSignals ERROR: code=' + http_code + ', data=' + data);
            $scope.actionStatus[docID] = 'Signals submissions failed.';
          });
        $log.debug('***END OF submitSignals');
      };

      // SoC -- set focus to search
      angular.element(document).ready(function () {
        document.getElementById('searchBoxEl').focus();
        document.getElementById('searchIconEl').click();
      });

    });
})();
