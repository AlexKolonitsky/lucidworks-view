(function () {
  'use strict';

  angular
    .module('lucidworksView.controllers.simulation', [
      'lucidworksView.services.simulation',
      'lucidworksView.services.config',
      'lucidworksView.services.auth'
    ])
    .controller('simulationController', function ($scope, $rootScope, $http, $sce, $window,
                                                  $interval, $timeout, $q, SimulationService, ConfigService, AuthService) {

      $rootScope.lw = ConfigService.config.simulation;

      $scope.showUIOptions = false;

      $rootScope.lw.pipelineIds = $rootScope.lw.pipelineIdList.split(','); //Derive a pipeline array from comma-delimited list
      $rootScope.lw.pipename = $rootScope.lw.pipelineIds[0]; //Default pipeline witll be the 1st one in $rootScope.lw.pipelineIds
      $rootScope.lw.requestHandlers = $rootScope.lw.requestHandlerList.split(','); //Derive an array from comma-delimited list
      $rootScope.lw.requestHandler = $rootScope.lw.requestHandlers[0]; //This specifies the requestHandler the main doSearch() will use.

      $scope.fields = $rootScope.lw.fl2display.split(',');

      $rootScope.lw.demo_actions_enabled = false; //demo_actions_enabled allows user to edit field values and submit signals
      $rootScope.lw.sort_by = 'default'; //'default' means sort by relevance.  User can select a different sort in the UI
      $rootScope.lw.sort_order = 'asc'; //'asc' for ascending, 'desc' is for descending

      $rootScope.lw.geo_enabled = false;
      $rootScope.lw.address = '';
      $rootScope.lw.coordinates = '';
      $rootScope.lw.geoMessage = '';

      $rootScope.lw.typeahead_logs_collection = $rootScope.lw.collection + '_logs';
      $rootScope.lw.typeahead_signals_collection = $rootScope.lw.collection + '_signals_aggr';

      $rootScope.lw.mm_options = [
        {label: 'Default', value: 'default'},
        {label: 'At least 2 terms', value: '2'},
        {label: 'At least 3 terms', value: '3'},
        {label: 'At least 50% of terms', value: '50%25'},
        {label: 'All search terms', value: '100%25'}
      ];
      $rootScope.lw.mm = 'default';

      $scope.q = '';
      $scope.search_within_q = '';
      $scope.fq = [];

      // rules SoC
      $scope.rules_exclude = [];

      $scope.showResponseHeader = false;
      $scope.showResponse = false;
      $scope.showDebug = false;
      $scope.showExplain = false;
      $scope.isFacetFilterOpen = true; //Set to true to open Facet accordian at startup
      $scope.shortList = false; //Set to false to display full facet result
      $scope.notification_enabled = false; //Notifition window is hidden initially
      $scope.notification_msg = '';

      $scope.actionStatus = {};
      $scope.explain = {};
      $scope.rebuildSpellcheckerStatus = '';
      $scope.rebuildSuggesterStatus = '';

      $scope.boost = []; //This array stores boost values listed in responseHeader.  Boost values are generated by signal-enabled query pipeline
      $scope.top_ten_searches = []; //This array holds the results of querying <collection>_logs for top 10 searches
      $scope.top_ten_docs = []; //This array holds the results of querying <collection>logs for top 10 clicked docs

      $scope.clearSearchBox = function () {
        console.log('***Clear Search Box... This function is called when you hit the "Clear" button');
        $scope.q = '';
        $scope.search_within_q = '';
        $scope.fq = [];
        if ($rootScope.lw.address != 'Current Location') {
          $rootScope.lw.address = '';
          $rootScope.lw.coordinates = '';
          $rootScope.lw.geoMessage = '';
        }
        $scope.actionStatus = {};
        $scope.explain = {};
        $scope.rebuildSpellcheckerStatus = '';
        $scope.rebuildSuggesterStatus = '';
        $scope.data = {};
        $scope.facet_fields = {};
        $scope.facet_fields_count = 0;
        $scope.spellcheck_results = [];
      };

      $scope.doSearch = function (start) {
        console.log("***BEGINNING OF doSearch... the main search function");

        var within = ''; //Search within results
        if ($rootScope.lw.search_within_results_enabled && $scope.search_within_q) {
          within = '&fq={!edismax}"' + $scope.search_within_q + '"';
        }

        var tagsSelected = $('div#tagsFilterWrapper button.depressed');
        var incexlStr = tagsSelected.length ? '&tags=' : '';
        $.each(tagsSelected, function (idx, el) {
          console.info(idx + ") Depressed: " + el);
          incexlStr += el.dataset['facet_label'] + ',';
        });

        var rules_exclude = '';
        var excl$ = $('div#applicableRulesEl button.excluded');
        $.each(excl$, function (idx, el) {
          var ruleId = el.dataset.ruleid;
          console.log(idx + ") Exclude: " + ruleId);

          rules_exclude += '&rules.exclude=' + ruleId;
        });
        console.info('rules.exclude=' + rules_exclude);


        $scope.notification_enabled = false;
        $scope.notification_msg = '';
        $scope.actionStatus = {};
        $scope.facet_fields = {};
        $scope.facet_fields_count = 0;
        $scope.spellcheck_results = [];
        $scope.explain = {};

        $('div#tagsFilterFooterWrapper').html(incexlStr);

        SimulationService.search($rootScope.lw, $scope.q, $scope.fq, within, start, rules_exclude, incexlStr,
          function (data, http_code, headers, config) {
          //With success, add INFO message to console and pass http response to search page fields
          console.log('doSearch SUCCESS: code=' + http_code + ', data=');
          console.log(data);
          processData(data);
          processFacetFields(data);
          processBoost(data);
          if ($rootScope.lw.spellcheck_enabled && $scope.q) {
            $scope.doSpellcheck()
          }
        },
          function (data, http_code, headers, config) {
            console.log('doSearch ERROR! code=' + http_code + ', data=');
            console.log(data);
            var msg = 'url = <a href="' + config.url + '" target="_blank">' + config.url + '</a><br/>';
            msg += 'method = ' + config.method + '<br/>';
            if (angular.isDefined(data.error)) {
              msg += 'response code = ' + http_code + ' (' + data.error.msg + ')';
            } else if (angular.isDefined(data.msg)) {
              msg += 'response code = ' + http_code + ' (' + data.msg + ')';
            } else {
              msg += 'response code = ' + http_code + '<br/>' + data;
            }
            $scope.notification_enabled = true;
            $scope.notification_msg = $sce.trustAsHtml(msg);
          });

        console.log("***END OF doSearch");
      };

      function processData(data) {
        // This function is executed when doSearch $http.get is SUCCESSFUL.
        $scope.showResponseHeader = false;
        $scope.showResponse = false;
        $scope.showDebug = false;

        $scope.data = data;

        $scope.start = data.response.start;
        $scope.numFound = data.response.numFound;
        $scope.pageSize = data.responseHeader.params.rows;
        $scope.currentPage = ($scope.start / $scope.pageSize) + 1;

        $scope.numPages = Math.ceil($scope.numFound / $scope.pageSize);
        if ($scope.numPages > 10) {
          $scope.showPages = new Array(10); //Show a max of 10 paging boxes
        } else {
          $scope.showPages = new Array($scope.numPages);
        }

        if (angular.isArray(data.responseHeader.params.fq)) {
          $scope.fq = data.responseHeader.params.fq;
        }
      }

      function processFacetFields(data) {
        console.log('***BEGINNING of processFacetFields... from Fusion http.get query');
        var facet_fields = {};

        //Only do if facet_fields exist in JSON response
        if (angular.isDefined(data.facet_counts)) {
          for (var facet in data.facet_counts.facet_fields) {
            var facet_bucket = data.facet_counts.facet_fields[facet];

            if (facet_bucket.length > 0) {
              var new_facet_bucket = [];
              for (var i = 0; i < facet_bucket.length; i++) {
                var facet_line = {};
                if (i % 2 == 0) {
                  facet_line.label = facet_bucket[i] + ' (' + facet_bucket[i + 1] + ')';
                  facet_line.name = facet_bucket[i];
                  facet_line.fq = facet + ':"' + facet_bucket[i] + '"';
                  facet_line.checked = $scope.checkFq(facet_line.fq);

                  new_facet_bucket.push(facet_line);
                }
              }
              facet_fields[facet] = new_facet_bucket;
            }
          }
        }
        $scope.facet_fields = facet_fields;
        console.log(facet_fields);
        $scope.facet_fields_count = Object.keys($scope.facet_fields).length;
        console.log('facet_fields_count=' + $scope.facet_fields_count);
        console.log('***END OF processFacetFields');
      }

      //***END OF processFacetFields

      //***processBoost from Fusion http.get query
      function processBoost(data) {
        console.log("***BEGINNING OF processBoost");
        var boost;
        $scope.boost = [];
        if (data.responseHeader.params.boost) {
          console.log('processBoost: boost field');
          boost = data.responseHeader.params.boost;
          console.log('typeof(boost): ' + typeof(boost));
          var boost_array = [];
          if (typeof(boost) == "string") {
            boost_array.push(boost);
          } else {
            boost_array = boost;
          }
          for (var i = 0; i < boost_array.length; i++) {
            var item = boost_array[i];
            console.log(item);
            if (/^map\(query\(\{!field f='id'/.test(item)) {
              var m = item.match(/v='([^']*)'/);
              var p = item.split(", ");
              $scope.boost[m[1]] = p[4].match(/[0-9\.]+/)[0];
            }
          }
        } else if (data.responseHeader.params.bq) {
          console.log('processBoost: bq field');
          boost = data.responseHeader.params.bq;
          console.log('typeof(boost): ' + typeof(boost));
          var boost_array = [];
          if (typeof(boost) == "string") {
            boost_array.push(boost);
          } else {
            boost_array = boost;
          }
          console.log('boost_array:');
          console.log(boost_array);
          for (var i = 0; i < boost_array.length; i++) {
            var item = boost_array[i];
            console.log(item);
            if (/^id:/.test(item)) {
              var m = item.match(/^id:(.*)/);
              var p = m[1].split("^");
              $scope.boost[p[0]] = p[1];
            }
          }
        }
        // console.log($scope.boost);
        console.log("***END OF processBoost");
      }

      //***END OF processBoost


      //***reDoSearch.  When user click on a Top Ten Search value or Spellcheck suggestion, redo search using new value
      $scope.reDoSearch = function (val) {
        $scope.q = val;
        $scope.doSearch(0);
      };
      //***END OF reDoSearch


      //***doPipelineChange.  When user changes his pipeline selection
      $scope.doPipelineChange = function () {
        console.log('***doPipelineChange');
        $rootScope.lw.sort_by = 'default';
        $scope.data = {};
        $scope.doSearch(0);
      };
      //***END OF doPipelineChange


      $scope.doRequestHandlerChange = function () {
        console.log('***doRequestHandlerChange When user changes his requestHandler selection');
        $scope.data = {};
        $scope.doSearch(0);
      };

      $scope.doMmChange = function () {
        console.log('***doMmChange');
        console.log('lw.mm=' + $rootScope.lw.mm);
        $scope.data = {};
        $scope.doSearch(0);
      };


      $scope.doSpellcheck = function () {
        console.log("***BEGINNING of doSpellcheck. This is executed when we get 0 docs from doSearch()");

        $scope.notification_enabled = false;
        $scope.notification_msg = '';

        var url = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + $rootScope.lw.collection +
          '/' + $rootScope.lw.spellcheck_requesthandler + '?wt=json&spellcheck.q=' + $scope.q + '&spellcheck.dictionary=' + $rootScope.lw.spellcheck_dictionary;
        console.log('url=' + url);

        //Perform http.get for doSpellcheck
        $http.get(url, $rootScope.lw.authorizationHeader).success(function (data, http_code, headers, config) {
          console.log('doSpellcheck SUCCESS: code=' + http_code + ', data=');
          console.log(data);

          if (angular.isDefined(data.spellcheck.collations)) {
            console.log('spellcheck.collations...');
            var collations = data.spellcheck.collations;
            var results = [];
            for (var i = 0; i < collations.length; i++) {
              if (angular.isObject(collations[i])) {
                console.log(collations[i]);
                var payload = {};
                payload['label'] = collations[i]['collationQuery'] + ' (' + collations[i]['hits'] + ')';
                payload['value'] = collations[i]['collationQuery'];
                results.push(payload);
              }
            }
          } else if (angular.isDefined(data.spellcheck.suggestions)) {
            console.log('spellcheck.suggestions...');
            var collations = data.spellcheck.suggestions;
            var results = [];
            for (var i = 0; i < collations.length; i++) {
              if (angular.isArray(collations[i])) {
                var j = collations[i];
                console.log(j);
                var payload = {};
                payload['label'] = j[1] + ' (' + j[3] + ')';
                payload['value'] = j[1];
                results.push(payload);
              }
            }
          }
          console.log(results);
          $scope.spellcheck_results = results;
        }).error(function (data, http_code, headers, config) {
          console.log('doSpellcheckh ERROR! code=' + http_code + ', data=');
          console.log(data);
          var msg = 'url = <a href="' + config.url + '" target="_blank">' + config.url + '</a><br/>';
          msg += 'method = ' + config.method + '<br/>';
          if (angular.isDefined(data.error)) {
            msg += 'response code = ' + http_code + ' (' + data.error.msg + ')';
          } else if (angular.isDefined(data.msg)) {
            msg += 'response code = ' + http_code + ' (' + data.msg + ')';
          } else {
            msg += 'response code = ' + http_code + '<br/>' + data;
          }
          $scope.notification_enabled = true;
          $scope.notification_msg = $sce.trustAsHtml(msg);
        });

        console.log("***END OF doSpellcheck");
      };
      //***END OF doSpellcheck

      //***This function will return true if value is NOT an object.  It is used to determine whether I enable user to edit field value.
      //***At this time, I only support field value edits for single-value fields.
      $scope.isValueNotAnObject = function (doc, field, value) {
        var value_type = angular.isObject(value);
        value_type = !value_type;
        //console.log('doc=' + doc + ', field=' + field + ', value=' + value +  ', value_type=' + value_type);
        return value_type;
      }
      //***END OF isValueNotAnObject


      //***This function is use to determine if a doc field value exist so we can decide whether to display field name or not
      $scope.isValueDefined = function (val) {
        return angular.isDefined(val);
      };
      //***END OF isValueDefined;


      //***If Value is an array, use join to make it into a string.
      $scope.returnValue = function (val) {
        var x
        if (angular.isArray(val)) {
          x = val.join(', ');
        } else {
          x = val;
        }
        return x;
      };
      //***END OF returnValue


      //***TypeAheadSearch.   This is executed every time you type a character in search box.
      $scope.typeAheadSearch = function (val) {

        console.log('***BEGINNING OF typeAheadSearch');

        //We will have a promises array to collect all suggestions from every "enabled" typeahead mechanisms below.
        var promises = [];

        $scope.notification_enabled = false;
        $scope.notification_msg = '';

        var fields = $rootScope.lw.typeahead_terms_fl.split(',');

        if ($rootScope.lw.typeahead_terms_enabled) promises.push(typeAheadViaTerms(val, fields, $rootScope.lw.collection));
        if ($rootScope.lw.typeahead_suggester1_enabled) promises.push(typeAheadViaSuggester(val, $rootScope.lw.typeahead_suggester1_dictionary, $rootScope.lw.collection));
        if ($rootScope.lw.typeahead_suggester2_enabled) promises.push(typeAheadViaSuggester(val, $rootScope.lw.typeahead_suggester2_dictionary, $rootScope.lw.collection));
        if ($rootScope.lw.typeahead_logs_collection_enabled) promises.push(typeAheadViaSystemCollection(val, ['q_s'], $rootScope.lw.typeahead_logs_collection));
        if ($rootScope.lw.typeahead_signals_collection_enabled) promises.push(typeAheadViaSystemCollection(val, ['query_s'], $rootScope.lw.typeahead_signals_collection));

        return $q.all(promises).then(function (data) {
          console.log('$q.all data=');
          console.log(data);
          var results = [];

          for (var i = 0; i < data.length; i++) {
            var bucket = data[i];
            for (var j = 0; j < bucket.length; j++) {
              results.push(bucket[j]);
            }
          }
          console.log('results=')
          console.log(results);
          console.log('***END OF typeAheadSearch');
          return (results);
        });
      };
      //***END OF typeAheadSearch

      //***Get typeahead via terms requestHander
      function typeAheadViaTerms(val, fields, collection) {
        console.log('***BEGINNING OF typeAheadViaTerms');
        var terms_fl = '';
        for (var k = 0; k < fields.length; k++) {
          terms_fl += '&terms.fl=' + fields[k];
        }

        var url = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + collection
          + '/' + $rootScope.lw.typeahead_terms_requesthandler + '?wt=json&terms.sort=count&terms.limit=' + $rootScope.lw.typeahead_retrieve_num
          + terms_fl + '&terms.prefix=' + val;
        console.log('url=' + url);

        return $http.get(url, $rootScope.lw.authorizationHeader).error(function (data, http_code, headers, config) {
          console.log('typeAheadViaTerms ERROR! code=' + http_code + ', data=');
          console.log(data);
          var msg = 'url = <a href="' + config.url + '" target="_blank">' + config.url + '</a><br/>';
          msg += 'method = ' + config.method + '<br/>';
          if (angular.isDefined(data.error)) {
            msg += 'response code = ' + http_code + ' (' + data.error.msg + ')';
          } else if (angular.isDefined(data.msg)) {
            msg += 'response code = ' + http_code + ' (' + data.msg + ')';
          } else {
            msg += 'response code = ' + http_code + '<br/>' + data;
          }
          $scope.notification_enabled = true;
          $scope.notification_msg = $sce.trustAsHtml(msg);
          return false;

        }).then(function (response) {
          console.log('typeAheadViaTerms response=');
          console.log(response);

          var results = [];
          for (var j = 0; j < fields.length; j++) {
            var field = fields[j];
            console.log('terms for ' + field);
            var d = response.data.terms[field];
            console.log(d);
            for (var i = 0; i < d.length; i++) {
              if (i % 2 == 0) {
                var payload = {};
                payload.helper = 'from ' + field + ' field';
                payload.display_value = d[i];
                if ($rootScope.lw.field_fq_enabled) {
                  payload.value = field + ':"' + d[i] + '"';
                } else {
                  payload.value = d[i];
                }
                results.push(payload);
              }
            }
          }
          console.log('***END OF typeAheadViaTerms');
          return results;
        })
      }

      //***END OF typeAheadViaTerms

      //***Get typeahead via suggester requestHander
      function typeAheadViaSuggester(val, dictionary, collection) {
        console.log('***BEGINNING OF typeAheadViaSuggester');
        var url = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + collection
          + '/' + $rootScope.lw.typeahead_suggester_requesthandler + '?wt=json&suggest.count=' + $rootScope.lw.typeahead_retrieve_num
          + '&suggest.dictionary=' + dictionary + '&suggest.q=' + val;
        console.log('url=' + url);

        return $http.get(url, $rootScope.lw.authorizationHeader).error(function (data, http_code, headers, config) {
          console.log('typeAheadViaSuggester ERROR! code=' + http_code + ', data=');
          console.log(data);
          var msg = 'url = <a href="' + config.url + '" target="_blank">' + config.url + '</a><br/>';
          msg += 'method = ' + config.method + '<br/>';
          if (angular.isDefined(data.error)) {
            msg += 'response code = ' + http_code + ' (' + data.error.msg + ')';
          } else if (angular.isDefined(data.msg)) {
            msg += 'response code = ' + http_code + ' (' + data.msg + ')';
          } else {
            msg += 'response code = ' + http_code + '<br/>' + data;
          }
          $scope.notification_enabled = true;
          $scope.notification_msg = $sce.trustAsHtml(msg);
          return false;
        }).then(function (response) {
          console.log('typeAheadViaSuggester response=');
          console.log(response);

          var results = [];
          var d = response.data.suggest[dictionary][val].suggestions;
          console.log(d);
          for (var i = 0; i < d.length; i++) {
            var payload = {};
            var term = d[i].term;
            term = term.replace(/<b>/g, '').replace(/<\/b>/g, '');
            payload.helper = 'from ' + dictionary;
            payload.display_value = term;
            payload.value = term;
            results.push(payload);
          }
          console.log('***END OF typeAheadViaSuggester');
          return results;
        });

      }

      //***END OF typeAheadViaSuggester

      //***Get suggestion via logs and signals collections
      function typeAheadViaSystemCollection(val, fields, collection) {
        console.log('***BEGINNING OF typeAheadViaSystemCollection');
        var terms_fl = '';
        for (var k = 0; k < fields.length; k++) {
          terms_fl += '&terms.fl=' + fields[k];
        }
        var url = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + collection +
          '/' + $rootScope.lw.typeahead_terms_requesthandler + '?wt=json&terms.sort=count&terms.limit=' + $rootScope.lw.typeahead_retrieve_num + terms_fl + '&terms.prefix=' + val;
        console.log('url=' + url);

        return $http.get(url, $rootScope.lw.authorizationHeader).error(function (data, http_code, headers, config) {
          console.log('typeAheadViaSysemCollection ERROR! code=' + http_code + ', data=');
          console.log(data);
          var msg = 'url = <a href="' + config.url + '" target="_blank">' + config.url + '</a><br/>';
          msg += 'method = ' + config.method + '<br/>';
          if (angular.isDefined(data.error)) {
            msg += 'response code = ' + http_code + ' (' + data.error.msg + ')';
          } else if (angular.isDefined(data.msg)) {
            msg += 'response code = ' + http_code + ' (' + data.msg + ')';
          } else {
            msg += 'response code = ' + http_code + '<br/>' + data;
          }
          $scope.notification_enabled = true;
          $scope.notification_msg = $sce.trustAsHtml(msg);
          return false;
        }).then(function (response) {
          var results = [];
          for (var j = 0; j < fields.length; j++) {
            var field = fields[j];
            console.log('terms for ' + field);
            var d = response.data.terms[field];
            console.log(d);
            //***solr json format for /terms requesthandler is array [] when distrib=false, but list {} when distrib=true!!!  Crazy!
            if (angular.isArray(d)) {
              for (var i = 0; i < d.length; i++) {
                if (i % 2 == 0) {
                  var payload = {};
                  payload.helper = 'from ' + collection;
                  payload.display_value = d[i];
                  payload.value = d[i];
                  results.push(payload);
                }
              }
            } else {
              var k = Object.keys(d);
              console.log(k);
              for (var i = 0; i < k.length; i++) {
                var payload = {};
                payload.helper = 'from ' + collection;
                payload.display_value = k[i];
                payload.value = k[i];
                results.push(payload);
              }
            }

          }
          console.log('***END OF typeAheadViaSystemCollection');
          return results;
        })
      }

      //***END OF typeAheadFromSystemCollection


      //*** updateRules
      $scope.updateRules = function (evnt, item) {
        // todo -- I have no idea what I'm doing in angular, need to refactor to be cool, going with jquery experience... SoC
        // try: http://geniuscarrier.com/ng-toggle-in-angularjs/
        console.info('Item:');
        var btn$ = $('button#rule_btn_' + item.id);
        btn$.toggleClass('excluded');
        $scope.doSearch(0);
      };


      /**
       * helper to filter clicked facet button from ui
       * @param facet -- string value at the moment
       * @todo revisit param, will have problems with spaces and lots of other unforeseen issues
       */
      $scope.updateTagsFilter = function (facet) {
        // todo -- I have no idea what I'm doing in angular, need to refactor to be cool, going with jquery experience... SoC
        console.info('exclude tags by Facet: ' + facet);
        var btn$ = $('button.tagsButton.' + facet);
        // var btn$ = $('button#rule_btn_' + item.id);
        btn$.toggleClass('depressed');
        $scope.doSearch(0);
      };


      //***updateFq.  This is executed when user clicks on facet in UI
      $scope.updateFq = function (checked, item) {
        if (!checked) {
          $scope.fq.push(item);
        } else {
          var i;
          for (i in $scope.fq) {
            if ($scope.fq[i] == item) {
              $scope.fq.splice(i, 1);
              break;
            }
          }
        }
        console.log('fq=');
        console.log($scope.fq);
        //redo search
        $scope.doSearch(0);
      };
      //***END OF updateFq

      //***checkFq. Used by processFieldFacets to determine if facet is alreay in $scope.fq array
      $scope.checkFq = function (item) {
        for (var i = 0; i < $scope.fq.length; i++) {
          if (item == $scope.fq[i]) return true;
        }
        return false;
      };
      //***END OF checkFq

      //***toggle_geo_enabled.  This is execute when user click on the globe next to main search box.  This toggles geospatial search
      $scope.toggle_geo_enabled = function () {
        if ($rootScope.lw.geo_enabled == true) {
          $rootScope.lw.geo_enabled = false;
          $rootScope.lw.sort_by = 'default';
          $scope.doSearch(0);
        } else {
          $rootScope.lw.geo_enabled = true;
          $rootScope.lw.sort_by = 'distance';
          if ($rootScope.lw.coordinates != '') {
            $scope.doSearch(0)
          }
        }
      };
      //***END OF toggle_geo_enabled

      //***doGeocode using Google geocode API
      $scope.doGeocode = function () {
        if ($rootScope.lw.address == '') {
          $rootScope.lw.geoMessage = 'Please enter a valid address';
          $rootScope.lw.geo_enabled = false;
          $rootScope.lw.sort_by = 'default';
          return;
        }
        if ($rootScope.lw.address == 'Current Location') {
          $scope.getCurrentLocation();
          return;
        }

        $rootScope.lw.geoMessage = '';
        $rootScope.lw.coordinates = '';
        $scope.http_request = 'http://maps.googleapis.com/maps/api/geocode/json?address=' + $rootScope.lw.address;

        //Perform http.get
        $http.get($scope.http_request).success(function (data, http_code, headers, config) {
          //With success, add INFO message to console and pass http response to search page fields
          console.log('doGeocode SUCCESS: code=' + http_code + ', data=');
          console.log(data);
          console.log('header=');
          console.log(headers);
          console.log('config=');
          console.log(config);
          if (data.status == "OK") {
            $rootScope.lw.coordinates = data.results[0].geometry.location.lat + ',' + data.results[0].geometry.location.lng;
            $rootScope.lw.geo_enabled = true;
            $rootScope.lw.sort_by = 'distance';
            $scope.doSearch(0);
          } else {
            $rootScope.lw.geoMessage = 'Google Geocode error: ' + data.status + ' for ' + $rootScope.lw.address;
            $rootScope.lw.geo_enabled = false;
            $rootScope.lw.sort_by = 'default';
          }
        }).error(function (data, http_code, headers, config) {
          console.log('doGeocode ERROR! code=' + http_code + ', data=');
          console.log(data);
          console.log('header=');
          console.log(headers);
          console.log('config=');
          console.log(config);
          $rootScope.lw.geoMessage = 'Google Geocode is UNREACHABLE: httpCode=' + http_code;
          $rootScope.lw.geo_enabled = false;
          $rootScope.lw.sort_by = 'default';
        });
      };
      //***END OF doGeocode

      //***Get device/browser current location for geospatial search
      $scope.getCurrentLocation = function () {
        $rootScope.lw.geoMessage = '';
        $rootScope.lw.coordinates = '';
        $rootScope.lw.address = "Current Location";
        if (navigator.geolocation) {
          // timeout at 60000 milliseconds (60 seconds)
          var options = {timeout: 60000};
          navigator.geolocation.getCurrentPosition($scope.setLocation, $scope.errorHandler, options);
        } else {
          alert("Sorry, browser does not support geolocation!");
        }
        $rootScope.lw.sort_by = 'distance';
      };
      $scope.setLocation = function (position) {
        var latitude = position.coords.latitude;
        var longitude = position.coords.longitude;
        console.log("Latitude : " + latitude + " Longitude: " + longitude);
        $rootScope.lw.coordinates = latitude + ',' + longitude;

        $rootScope.lw.geo_enabled = true;
        $rootScope.lw.sort_by = 'distance';
        $scope.doSearch(0);
      };

      $scope.errorHandler = function (err) {
        if (err.code == 1) {
          alert("Error: Access is denied!");
        } else if (err.code == 2) {
          alert("Error: Position is unavailable!");
        }
      };

      //***END OF section for getting device/browser current location


      //***If head field value is blank, then set text to "_blank_"
      $scope.displayHeadField = function (text) {
        if (!angular.isDefined(text)) {
          text = "_empty_";
        } else if (angular.isArray(text)) {
          text = text.join(', ');
        } else if (text.trim() == "") {
          text = "_blank_";
        }
        return text;
      };

      //***returnMappedLabel.  Use labels for field name if labels are specified in $rootScope.lw.labels
      $scope.returnMappedLabel = function (val) {
        return $sce.trustAsHtml($rootScope.lw.labels[val] || val);
      };

      //***doTopTenDocsAction.  Similar to docHeadFieldAction but not signals submissions
      $scope.doTopTenDocsAction = function (docID, docHeadFieldValue, urlFieldName, urlFieldValue) {
        console.log('doTopTenDocsAction docID:' + docID + ', docHeadFieldValue:' + docHeadFieldValue + ', urlFieldName:' + urlFieldName + ', urlFieldValue:' + urlFieldValue);

        if (urlFieldName.indexOf("coord") > -1) {
          window.open('https://maps.google.com/maps?q=' + urlFieldValue, '_blank');
        } else if (urlFieldValue.toString().indexOf("http") == 0) {
          window.open(urlFieldValue, '_blank');
        } else if (urlFieldValue.toString().indexOf("www.") == 0) {
          window.open('http://' + urlFieldValue, '_blank');
        } else if (docHeadValue.toString().indexOf("http") == 0) {
          window.open(docHeadValue, '_blank');
        }
        return false;
      };
      //***END OF doTopTenDocsAction


      /**
       * This function controls the behavior of head field click action.
       * When "Demo Actions" is enabled, clicking a doc head field will trigger submission of signals (clicks).
       * Otherwise, click a doc head field will trigger action based on $rootScope.lw.head_url_field
       * and head url field value.
       * */
      $scope.doHeadFieldAction = function (docID, docHeadFieldValue, urlFieldName, urlFieldValue) {
        console.log('doHeadAction docID:' + docID + ', docHeadFieldValue:' + docHeadFieldValue + ', urlFieldName:' + urlFieldName + ', urlFieldValue:' + urlFieldValue);

        if ($rootScope.lw.demo_actions_enabled) {
          if ($scope.q) {
            $scope.submitSignals(docID);
          } else {
            $scope.actionStatus[docID] = "You need to search for something 1st before you can submit clicks.";
          }
        } else {
          if (urlFieldName != '' && urlFieldName == $rootScope.lw.geofield) {
            window.open('https://maps.google.com/maps?q=' + urlFieldValue, '_blank');
          } else if (urlFieldValue.toString().indexOf("http") == 0) {
            window.open(urlFieldValue, '_blank');
          } else if (urlFieldValue.toString().indexOf("www.") == 0) {
            window.open('http://' + urlFieldValue, '_blank');
          } else if (docHeadValue.toString().indexOf("http") == 0) {
            window.open(docHeadValue, '_blank');
          }
        }
        return false;
      };

      $scope.getThumbnailUrl = function (thumbnail_field_value) {

        var thumbnail_field = $rootScope.lw.thumbnail_field;

        if (angular.isArray(thumbnail_field_value)) {
          thumbnail_field_value = thumbnail_field_value.join(',');
        }

        if (thumbnail_field == $rootScope.lw.geofield) {
          return 'https://maps.googleapis.com/maps/api/streetview?&key=AIzaSyCL2yMd2faskEVdfNsxTbY_q84U6wt4a5A&size=120x120&location=' + thumbnail_field_value;
        } else if (thumbnail_field == 'prod_id') {
          return 'http://rei.com/zoom/' + thumbnail_field_value;
        } else {
          return thumbnail_field_value;
        }
      };


      //***doRebuildSpellchecker
      $scope.doRebuildSpellchecker = function () {
        $scope.rebuildSpellcheckerStatus = 'Spellchecker rebuild initiated.';

        var url = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + $rootScope.lw.collection
          + '/' + $rootScope.lw.spellcheck_requesthandler + '?spell.build=true';
        console.log('url=' + url);
        $http.get(url, $rootScope.lw.authorizationHeader).success(function (data, http_code) {
            console.log('doRebuildSpellchecker SUCCESS: code=' + http_code + ', data=');
            console.log(data);
            $scope.rebuildSpellcheckerStatus = 'Spellchecker rebuild successful...';
          })
          .error(function (data, http_code) {
            console.log('doRebuildSpellchecker ERROR: code=' + http_code + ', data=');
            console.log(data);
            $scope.rebuildSpellcheckerStatus = 'Spellchecker rebuild failed with code = ' + http_code + '...';
          });
      };
      //***END OF doRebuildSpellchecker


      //***doRebuildSuggester
      $scope.doRebuildSuggester = function () {
        $scope.rebuildSuggesterStatus = 'Suggester rebuild initiated.  Please wait.';

        var url = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + $rootScope.lw.collection
          + '/' + $rootScope.lw.typeahead_suggester_requesthandler + '?suggest.buildAll=true';
        console.log('url=' + url);
        $http.get(url, $rootScope.lw.authorizationHeader).success(function (data, http_code) {
            console.log('doRebuildSuggester SUCCESS: code=' + http_code + ', data=');
            console.log(data);
            $scope.rebuildSuggesterStatus = 'Rebuild successful';
          })
          .error(function (data, http_code) {
            console.log('doRebuildSuggester ERROR: code=' + http_code + ', data=');
            console.log(data);
            $scope.rebuildSuggesterStatus = 'Rebuild failed with code = ' + http_code;
          });
      };
      //***END OF doRebuildSuggester


      //***BEGINNING OF getTopTenSearches
      $scope.getTopTenSearches = function () {
        console.log('***BEGINNING OF getTopTenSearches');

        //Top 10 Searches is achieved by facet <collection>_logs by q_s
        var url = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + $rootScope.lw.collection
          + '_logs/select?&wt=json&q=*:*&df=q_s&rows=0&facet=true&facet.field=q_s&facet.limit=10&facet.missing=false&fq=-{!term f=q_s}*:*';
        console.log('url=' + url);

        $http.get(url, $rootScope.lw.authorizationHeader)
          .error(function (data, http_code) {
            console.log('getTopTenSearches ERROR: code=' + http_code + ', data=' + data);
          })
          .then(function (response) {
            console.log('getTopTenSearches SUCCESS: response=');
            console.log(response);

            if (response.data.facet_counts.facet_fields) {
              var facet_bucket = response.data.facet_counts.facet_fields['q_s'];
              if (facet_bucket.length > 0) {

                var new_facet_bucket = [];

                for (var i = 0; i < facet_bucket.length; i++) {
                  var facet_line = {};
                  if (i % 2 == 0) {
                    facet_line.value = facet_bucket[i];
                    facet_line.label = facet_bucket[i] + ' (' + facet_bucket[i + 1] + ')';
                    if (facet_bucket[i + 1] != 0) {
                      new_facet_bucket.push(facet_line);
                    }
                  }
                }

                $scope.top_ten_searches = new_facet_bucket;
                console.log('extracted top_ten_searches=');
                console.log($scope.top_ten_searches);
              }
            }
          });
        console.log('***END OF getTopTenSearches');
      };


      $scope.getTopTenDocs = function () {
        console.log('***BEGINNING OF getTopTenDocs');

        var ids = [];
        var ids_encoded = [];
        var id_count = {};

        var url = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + $rootScope.lw.collection
          + '_signals_aggr/select?&wt=json&q=*:*&df=query_s&rows=0&facet=true&facet.field=doc_id_s&facet.limit=10&facet.missing=false';
        console.log('url=' + url);

        $http.get(url, $rootScope.lw.authorizationHeader)
          .error(function (data, http_code) {
            console.log('getTopTenDocs ERROR: code=' + http_code + ', data=' + data);
          })
          .then(function (response) {
            console.log('getTopTenDocs SUCCESS: response=');
            console.log(response);
            if (response.data.facet_counts.facet_fields) {
              var facet_bucket = response.data.facet_counts.facet_fields['doc_id_s'];
              if (facet_bucket.length > 0) {

                for (var i = 0; i < facet_bucket.length; i++) {
                  if (i % 2 == 0) {
                    var id = facet_bucket[i];
                    ids.push(id);
                    ids_encoded.push('"' + id.replace(/%/g, '%25').replace(/#/g, '%23') + '"');
                    id_count[id] = facet_bucket[i + 1];
                  }
                }

                console.log('id and id_count=');
                console.log(ids_encoded.join(' OR '));
                console.log(id_count);

                var url2 = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + $rootScope.lw.collection
                  + '/select?&wt=json&q=(' + ids_encoded.join(' OR ') + ')';
                console.log('url2=' + url2);

                $http.get(url2, $rootScope.lw.authorizationHeader)
                  .error(function (data, http_code) {
                    console.log('getTopTenDocs 2ND ERROR: code=' + http_code + ', data=' + data);
                  })
                  .then(function (response) {
                    console.log('getTopTenDocs 2ND SUCCESS: response=');
                    console.log(response);

                    var bucket = response.data.response.docs;
                    var head_field_values = {};
                    var head_url_values = {};
                    if (bucket.length > 0) {

                      var head_field_value;
                      var head_url_value;
                      for (var i = 0; i < bucket.length; i++) {
                        var id = bucket[i]['id'];
                        if (bucket[i][$rootScope.lw.head_field]) {
                          head_field_value = bucket[i][$rootScope.lw.head_field];
                        } else {
                          head_field_value = '_blank_';
                        }

                        if (bucket[i][$rootScope.lw.head_url_field]) {
                          head_url_value = bucket[i][$rootScope.lw.head_url_field];
                        } else {
                          head_url_value = '_blank_';
                        }

                        console.log('head_field_value=' + head_field_value + ' head_url_value=' + head_url_value);

                        head_field_values[id] = head_field_value;
                        head_url_values[id] = head_url_value;
                      }
                      console.log('head_field_values=');
                      console.log(head_field_values);
                      console.log('head_url_values=');
                      console.log(head_url_values);

                      var results = [];
                      for (var i = 0; i < ids.length; i++) {
                        var id = ids[i];
                        var j = {};
                        j['id'] = id;
                        j['label'] = head_field_values[id] + ' (' + id_count[id] + ')';
                        j[$rootScope.lw.head_field] = head_field_values[id];
                        j[$rootScope.lw.head_url_field] = head_url_values[id];

                        console.log('j=');
                        console.log(j);
                        results.push(j);
                      }
                      $scope.top_ten_docs = results;

                      console.log('extracted top_ten_docs=');
                      console.log($scope.top_ten_docs);
                    }
                  });

              }
            }
          });
        console.log('***END OF getTopTenDocs');
      };
      //***END OF getTopTenDocs


      //***doFieldUpdate.  This is used to update a field value in your solr collection
      $scope.doFieldUpdate = function (docID, field, value, orig_value) {
        console.log('***doFieldUpdate');
        var payload = [];
        var aDoc = {};
        aDoc["id"] = docID;
        if (!angular.isDefined(orig_value)) {
          console.log('orig_value is UNDEFINED');
          orig_value = 'UNDEFINED';
        }
        aDoc['_ORIG_' + field] = {"add": orig_value};
        payload.push(aDoc);
        console.log('payload=');
        console.log(payload);

        //Do http.post to solr update requestHandler to store original field value 1st
        var http_request = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + $rootScope.lw.collection + '/update?commit=true';
        $http.post(http_request, payload, $rootScope.lw.authorizationHeader).success(function (data, http_code) {
            console.log('doFieldUpdate for _ORIG_ SUCCESS: code=' + http_code + ', data=');
            console.log(data);
          })
          .error(function (data, http_code) {
            console.log('doFieldUpdate for _ORIG_ ERROR: code=' + http_code + ', data=' + data);
          });

        payload = [];
        aDoc = {};
        aDoc["id"] = docID;
        aDoc[field] = {"set": value};
        payload.push(aDoc);
        console.log('SECOND TIME payload=');
        console.log(payload);

        //Do http.post to solr update requestHandler to set NEW field value 1st
        http_request = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/solr/' + $rootScope.lw.collection + '/update?commit=true';
        $http.post(http_request, payload, $rootScope.lw.authorizationHeader).success(function (data, http_code) {
            console.log('doFieldUpdate for NEW field value - SUCCESS: code=' + http_code + ', data=');
            console.log(data);
            $scope.actionStatus[docID + field] = 'Save successful for "' + value + '"';
          })
          .error(function (data, http_code) {
            console.log('doFieldUpdate for NEW field value - ERROR: code=' + http_code + ', data=');
            console.log(data);
            if (data.error) {
              $scope.actionStatus[docID + field] = 'Save FAILED - ' + data.error.msg;
            } else {
              $scope.actionStatus[docID + field] = 'Save FAILED - CODE=' + http_code;
            }
          });

        console.log('***END OF doFieldUpdate');
      };


      //***This function submits signals to the <collection>_signals
      $scope.submitSignals = function (docID) {
        console.log('***BEGINNING OF submitSignals');
        var d = new Date();
        var ts = d.toISOString();
        var params = {};
        params["docId"] = docID;
        params["query"] = $scope.q;
        params["source_s"] = 'simulated';
        params["source_type_s"] = 'advUI';
        var signal_payload = {};
        signal_payload["type"] = $rootScope.lw.signalType;
        signal_payload["timestamp"] = ts;
        signal_payload["params"] = params;
        var indata = [];
        for (var i = 0; i < $rootScope.lw.signalNum; i++) {
          indata.push(signal_payload)
        }

        console.log(indata);

        var url = $rootScope.lw.host + ':' + $rootScope.lw.port + '/api/apollo/signals/' + $rootScope.lw.collection + '?commit=true'
          + '&pipeline=' + $rootScope.lw.signals_pipeline;
        console.log('url=' + url);

        //Perform http post for submitSignals
        $http.post(url, indata, $rootScope.lw.authorizationHeader).success(function (data, http_code) {
            console.log('submitSignals SUCCESS: code=' + http_code + ', data=');
            console.log(data);
            $scope.actionStatus[docID] = $rootScope.lw.signalNum + ' ' + $rootScope.lw.signalType + ' successfully submitted. docID=' + docID;
          })
          .error(function (data, http_code) {
            console.log('submitSignals ERROR: code=' + http_code + ', data=' + data);
            $scope.actionStatus[docID] = 'Signals submissions failed.';
          });
        console.log('***END OF submitSignals');
      };

      //This is used for collapsing/un-collapsing explain tree
      $scope.toggleTreeNode = function (scope) {
        scope.toggle();
      };
      //***END OF toggle


      // SoC -- set focus to search
      angular.element(document).ready(function () {
        var searchBox = document.getElementById('searchBoxEl');
        searchBox.focus();
        console.log("sets focus to search box");
        // doSearch(0);
        // console.info("Do search...");
        var searchIcon = document.getElementById('searchIconEl');
        searchIcon.click();
        console.log("clicked icon automatically");
      });

    });


})();
